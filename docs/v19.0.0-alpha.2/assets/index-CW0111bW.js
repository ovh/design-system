import{r as K,b as G,u as M,v as L,x as g,y as F,e as N,d as O,z as S,h as C,A as _,B as W}from"./index-BCxMAfLs.js";var y=new WeakMap,I=new WeakMap,k={},A=0,B=e=>e&&(e.host||B(e.parentNode)),$=(e,i)=>i.map(a=>{if(e.contains(a))return a;const t=B(a);return t&&e.contains(t)?t:(console.error("[zag-js > ariaHidden] target",a,"in not contained inside",e,". Doing nothing"),null)}).filter(a=>!!a),V=e=>e.localName==="next-route-announcer"||e.localName==="script"||e.hasAttribute("aria-live")?!0:e.matches("[data-live-announcer]"),H=(e,i)=>{const{parentNode:a,markerName:t,controlAttribute:s}=i,r=$(a,Array.isArray(e)?e:[e]);k[t]||(k[t]=new WeakMap);const o=k[t],u=[],l=new Set,n=new Set(r),d=c=>{!c||l.has(c)||(l.add(c),d(c.parentNode))};r.forEach(d);const b=c=>{!c||n.has(c)||Array.prototype.forEach.call(c.children,f=>{if(l.has(f))b(f);else try{if(V(f))return;const T=f.getAttribute(s)==="true",x=(y.get(f)||0)+1,v=(o.get(f)||0)+1;y.set(f,x),o.set(f,v),u.push(f),x===1&&T&&I.set(f,!0),v===1&&f.setAttribute(t,""),T||f.setAttribute(s,"true")}catch(p){console.error("[zag-js > ariaHidden] cannot operate on ",f,p)}})};return b(a),l.clear(),A++,()=>{u.forEach(c=>{const f=y.get(c)-1,p=o.get(c)-1;y.set(c,f),o.set(c,p),f||(I.has(c)||c.removeAttribute(s),I.delete(c)),p||c.removeAttribute(t)}),A--,A||(y=new WeakMap,y=new WeakMap,I=new WeakMap,k={})}},j=e=>(Array.isArray(e)?e[0]:e).ownerDocument.body,z=(e,i=j(e),a="data-aria-hidden")=>{if(i)return H(e,{parentNode:i,markerName:a,controlAttribute:"aria-hidden"})},X=e=>{const i=requestAnimationFrame(()=>e());return()=>cancelAnimationFrame(i)};function it(e,i={}){const{defer:a=!0}=i,t=a?X:r=>r(),s=[];return s.push(t(()=>{const o=(typeof e=="function"?e():e).filter(Boolean);o.length!==0&&s.push(z(o))})),()=>{s.forEach(r=>r==null?void 0:r())}}var Y=Object.defineProperty,q=(e,i,a)=>i in e?Y(e,i,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[i]=a,h=(e,i,a)=>q(e,typeof i!="symbol"?i+"":i,a),E={activateTrap(e,i){if(e.length>0){const t=e[e.length-1];t!==i&&t.pause()}const a=e.indexOf(i);a===-1||e.splice(a,1),e.push(i)},deactivateTrap(e,i){const a=e.indexOf(i);a!==-1&&e.splice(a,1),e.length>0&&e[e.length-1].unpause()}},J=[],Q=class{constructor(e,i){h(this,"trapStack"),h(this,"config"),h(this,"doc"),h(this,"state",{containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0,recentNavEvent:void 0}),h(this,"listenerCleanups",[]),h(this,"handleFocus",t=>{const s=O(t),r=this.findContainerIndex(s,t)>=0;if(r||S(s))r&&(this.state.mostRecentlyFocusedNode=s);else{t.stopImmediatePropagation();let o,u=!0;if(this.state.mostRecentlyFocusedNode)if(F(this.state.mostRecentlyFocusedNode)>0){const l=this.findContainerIndex(this.state.mostRecentlyFocusedNode),{tabbableNodes:n}=this.state.containerGroups[l];if(n.length>0){const d=n.findIndex(b=>b===this.state.mostRecentlyFocusedNode);d>=0&&(this.config.isKeyForward(this.state.recentNavEvent)?d+1<n.length&&(o=n[d+1],u=!1):d-1>=0&&(o=n[d-1],u=!1))}}else this.state.containerGroups.some(l=>l.tabbableNodes.some(n=>F(n)>0))||(u=!1);else u=!1;u&&(o=this.findNextNavNode({target:this.state.mostRecentlyFocusedNode,isBackward:this.config.isKeyBackward(this.state.recentNavEvent)})),o?this.tryFocus(o):this.tryFocus(this.state.mostRecentlyFocusedNode||this.getInitialFocusNode())}this.state.recentNavEvent=void 0}),h(this,"handlePointerDown",t=>{const s=O(t);if(!(this.findContainerIndex(s,t)>=0)){if(w(this.config.clickOutsideDeactivates,t)){this.deactivate({returnFocus:this.config.returnFocusOnDeactivate});return}w(this.config.allowOutsideClick,t)||t.preventDefault()}}),h(this,"handleClick",t=>{const s=O(t);this.findContainerIndex(s,t)>=0||w(this.config.clickOutsideDeactivates,t)||w(this.config.allowOutsideClick,t)||(t.preventDefault(),t.stopImmediatePropagation())}),h(this,"handleTabKey",t=>{if(this.config.isKeyForward(t)||this.config.isKeyBackward(t)){this.state.recentNavEvent=t;const s=this.config.isKeyBackward(t),r=this.findNextNavNode({event:t,isBackward:s});if(!r)return;m(t)&&t.preventDefault(),this.tryFocus(r)}}),h(this,"handleEscapeKey",t=>{U(t)&&w(this.config.escapeDeactivates,t)!==!1&&(t.preventDefault(),this.deactivate())}),h(this,"_mutationObserver"),h(this,"setupMutationObserver",()=>{const t=this.doc.defaultView||window;this._mutationObserver=new t.MutationObserver(s=>{s.some(o=>Array.from(o.removedNodes).some(l=>l===this.state.mostRecentlyFocusedNode))&&this.tryFocus(this.getInitialFocusNode())})}),h(this,"updateObservedNodes",()=>{var t;(t=this._mutationObserver)==null||t.disconnect(),this.state.active&&!this.state.paused&&this.state.containers.map(s=>{var r;(r=this._mutationObserver)==null||r.observe(s,{subtree:!0,childList:!0})})}),h(this,"getInitialFocusNode",()=>{let t=this.getNodeForOption("initialFocus",{hasFallback:!0});if(t===!1)return!1;if(t===void 0||t&&!C(t))if(this.findContainerIndex(this.doc.activeElement)>=0)t=this.doc.activeElement;else{const s=this.state.tabbableGroups[0];t=s&&s.firstTabbableNode||this.getNodeForOption("fallbackFocus")}else t===null&&(t=this.getNodeForOption("fallbackFocus"));if(!t)throw new Error("Your focus-trap needs to have at least one focusable element");return t.isConnected||(t=this.getNodeForOption("fallbackFocus")),t}),h(this,"tryFocus",t=>{if(t!==!1&&t!==_(this.doc)){if(!t||!t.focus){this.tryFocus(this.getInitialFocusNode());return}t.focus({preventScroll:!!this.config.preventScroll}),this.state.mostRecentlyFocusedNode=t,Z(t)&&t.select()}}),h(this,"deactivate",t=>{if(!this.state.active)return this;const s={onDeactivate:this.config.onDeactivate,onPostDeactivate:this.config.onPostDeactivate,checkCanReturnFocus:this.config.checkCanReturnFocus,...t};clearTimeout(this.state.delayInitialFocusTimer),this.state.delayInitialFocusTimer=void 0,this.removeListeners(),this.state.active=!1,this.state.paused=!1,this.updateObservedNodes(),E.deactivateTrap(this.trapStack,this);const r=this.getOption(s,"onDeactivate"),o=this.getOption(s,"onPostDeactivate"),u=this.getOption(s,"checkCanReturnFocus"),l=this.getOption(s,"returnFocus","returnFocusOnDeactivate");r==null||r();const n=()=>{P(()=>{if(l){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);this.tryFocus(d)}o==null||o()})};if(l&&u){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);return u(d).then(n,n),this}return n(),this}),h(this,"pause",t=>{if(this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onPause"),r=this.getOption(t,"onPostPause");return this.state.paused=!0,s==null||s(),this.removeListeners(),this.updateObservedNodes(),r==null||r(),this}),h(this,"unpause",t=>{if(!this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onUnpause"),r=this.getOption(t,"onPostUnpause");return this.state.paused=!1,s==null||s(),this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),r==null||r(),this}),h(this,"updateContainerElements",t=>(this.state.containers=Array.isArray(t)?t.filter(Boolean):[t].filter(Boolean),this.state.active&&this.updateTabbableNodes(),this.updateObservedNodes(),this)),h(this,"getReturnFocusNode",t=>{const s=this.getNodeForOption("setReturnFocus",{params:[t]});return s||(s===!1?!1:t)}),h(this,"getOption",(t,s,r)=>t&&t[s]!==void 0?t[s]:this.config[r||s]),h(this,"getNodeForOption",(t,{hasFallback:s=!1,params:r=[]}={})=>{let o=this.config[t];if(typeof o=="function"&&(o=o(...r)),o===!0&&(o=void 0),!o){if(o===void 0||o===!1)return o;throw new Error(`\`${t}\` was specified but was not a node, or did not return a node`)}let u=o;if(typeof o=="string"){try{u=this.doc.querySelector(o)}catch(l){throw new Error(`\`${t}\` appears to be an invalid selector; error="${l.message}"`)}if(!u&&!s)throw new Error(`\`${t}\` as selector refers to no known node`)}return u}),h(this,"findNextNavNode",t=>{const{event:s,isBackward:r=!1}=t,o=t.target||O(s);this.updateTabbableNodes();let u=null;if(this.state.tabbableGroups.length>0){const l=this.findContainerIndex(o,s),n=l>=0?this.state.containerGroups[l]:void 0;if(l<0)r?u=this.state.tabbableGroups[this.state.tabbableGroups.length-1].lastTabbableNode:u=this.state.tabbableGroups[0].firstTabbableNode;else if(r){let d=this.state.tabbableGroups.findIndex(({firstTabbableNode:b})=>o===b);if(d<0&&((n==null?void 0:n.container)===o||C(o)&&!g(o)&&!(n!=null&&n.nextTabbableNode(o,!1)))&&(d=l),d>=0){const b=d===0?this.state.tabbableGroups.length-1:d-1,c=this.state.tabbableGroups[b];u=F(o)>=0?c.lastTabbableNode:c.lastDomTabbableNode}else m(s)||(u=n==null?void 0:n.nextTabbableNode(o,!1))}else{let d=this.state.tabbableGroups.findIndex(({lastTabbableNode:b})=>o===b);if(d<0&&((n==null?void 0:n.container)===o||C(o)&&!g(o)&&!(n!=null&&n.nextTabbableNode(o)))&&(d=l),d>=0){const b=d===this.state.tabbableGroups.length-1?0:d+1,c=this.state.tabbableGroups[b];u=F(o)>=0?c.firstTabbableNode:c.firstDomTabbableNode}else m(s)||(u=n==null?void 0:n.nextTabbableNode(o))}}else u=this.getNodeForOption("fallbackFocus");return u}),this.trapStack=i.trapStack||J;const a={returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0,isKeyForward(t){return m(t)&&!t.shiftKey},isKeyBackward(t){return m(t)&&t.shiftKey},...i};this.doc=a.document||G(Array.isArray(e)?e[0]:e),this.config=a,this.updateContainerElements(e),this.setupMutationObserver()}get active(){return this.state.active}get paused(){return this.state.paused}findContainerIndex(e,i){const a=typeof(i==null?void 0:i.composedPath)=="function"?i.composedPath():void 0;return this.state.containerGroups.findIndex(({container:t,tabbableNodes:s})=>t.contains(e)||(a==null?void 0:a.includes(t))||s.find(r=>r===e))}updateTabbableNodes(){if(this.state.containerGroups=this.state.containers.map(e=>{const i=M(e),a=L(e),t=i.length>0?i[0]:void 0,s=i.length>0?i[i.length-1]:void 0,r=a.find(n=>g(n)),o=a.slice().reverse().find(n=>g(n)),u=!!i.find(n=>F(n)>0);function l(n,d=!0){const b=i.indexOf(n);return b<0?d?a.slice(a.indexOf(n)+1).find(c=>g(c)):a.slice(0,a.indexOf(n)).reverse().find(c=>g(c)):i[b+(d?1:-1)]}return{container:e,tabbableNodes:i,focusableNodes:a,posTabIndexesFound:u,firstTabbableNode:t,lastTabbableNode:s,firstDomTabbableNode:r,lastDomTabbableNode:o,nextTabbableNode:l}}),this.state.tabbableGroups=this.state.containerGroups.filter(e=>e.tabbableNodes.length>0),this.state.tabbableGroups.length<=0&&!this.getNodeForOption("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");if(this.state.containerGroups.find(e=>e.posTabIndexesFound)&&this.state.containerGroups.length>1)throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")}addListeners(){if(this.state.active)return E.activateTrap(this.trapStack,this),this.state.delayInitialFocusTimer=this.config.delayInitialFocus?P(()=>{this.tryFocus(this.getInitialFocusNode())}):this.tryFocus(this.getInitialFocusNode()),this.listenerCleanups.push(N(this.doc,"focusin",this.handleFocus,!0),N(this.doc,"mousedown",this.handlePointerDown,{capture:!0,passive:!1}),N(this.doc,"touchstart",this.handlePointerDown,{capture:!0,passive:!1}),N(this.doc,"click",this.handleClick,{capture:!0,passive:!1}),N(this.doc,"keydown",this.handleTabKey,{capture:!0,passive:!1}),N(this.doc,"keydown",this.handleEscapeKey)),this}removeListeners(){if(this.state.active)return this.listenerCleanups.forEach(e=>e()),this.listenerCleanups=[],this}activate(e){if(this.state.active)return this;const i=this.getOption(e,"onActivate"),a=this.getOption(e,"onPostActivate"),t=this.getOption(e,"checkCanFocusTrap");t||this.updateTabbableNodes(),this.state.active=!0,this.state.paused=!1,this.state.nodeFocusedBeforeActivation=this.doc.activeElement||null,i==null||i();const s=()=>{t&&this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),a==null||a()};return t?(t(this.state.containers.concat()).then(s,s),this):(s(),this)}},m=e=>e.key==="Tab",w=(e,...i)=>typeof e=="function"?e(...i):e,U=e=>!e.isComposing&&e.key==="Escape",P=e=>setTimeout(e,0),Z=e=>e.localName==="input"&&"select"in e&&typeof e.select=="function";function at(e,i={}){let a;const t=K(()=>{const s=typeof e=="function"?e():e;if(s){a=new Q(s,{escapeDeactivates:!1,allowOutsideClick:!0,preventScroll:!0,returnFocusOnDeactivate:!0,delayInitialFocus:!1,fallbackFocus:s,...i,document:G(s)});try{a.activate()}catch{}}});return function(){a==null||a.deactivate(),t()}}var D="data-scroll-lock";function R(e,i){if(!e)return;const a=Object.keys(i).reduce((t,s)=>(t[s]=e.style.getPropertyValue(s),t),{});return Object.assign(e.style,i),()=>{Object.assign(e.style,a)}}function tt(e,i,a){if(!e)return;const t=e.style.getPropertyValue(i);return e.style.setProperty(i,a),()=>{t?e.style.setProperty(i,t):e.style.removeProperty(i)}}function et(e){const i=e.getBoundingClientRect().left;return Math.round(i)+e.scrollLeft?"paddingLeft":"paddingRight"}function ot(e){const i=e??document,a=i.defaultView??window,{documentElement:t,body:s}=i;if(s.hasAttribute(D))return;s.setAttribute(D,"");const o=a.innerWidth-t.clientWidth,u=()=>tt(t,"--scrollbar-width",`${o}px`),l=et(t),n=()=>R(s,{overflow:"hidden",[l]:`${o}px`}),d=()=>{const{scrollX:c,scrollY:f,visualViewport:p}=a,T=(p==null?void 0:p.offsetLeft)??0,x=(p==null?void 0:p.offsetTop)??0,v=R(s,{position:"fixed",overflow:"hidden",top:`${-(f-Math.floor(x))}px`,left:`${-(c-Math.floor(T))}px`,right:"0",[l]:`${o}px`});return()=>{v==null||v(),a.scrollTo({left:c,top:f,behavior:"instant"})}},b=[u(),W()?d():n()];return()=>{b.forEach(c=>c==null?void 0:c()),s.removeAttribute(D)}}export{it as a,ot as p,at as t};
