import{r as R,b as D,z as G,A,B as p,C as g,l as v,d as y,D as B,o as T,E as P,F as K,y as O,G as L}from"./use-locale-context-DLC4Hyvy.js";var _=Object.defineProperty,S=(e,a,n)=>a in e?_(e,a,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[a]=n,l=(e,a,n)=>S(e,typeof a!="symbol"?a+"":a,n),I={activateTrap(e,a){if(e.length>0){const t=e[e.length-1];t!==a&&t.pause()}const n=e.indexOf(a);n===-1||e.splice(n,1),e.push(a)},deactivateTrap(e,a){const n=e.indexOf(a);n!==-1&&e.splice(n,1),e.length>0&&e[e.length-1].unpause()}},$=[],M=class{constructor(e,a){l(this,"trapStack"),l(this,"config"),l(this,"doc"),l(this,"state",{containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0,recentNavEvent:void 0}),l(this,"listenerCleanups",[]),l(this,"handleFocus",t=>{const s=y(t),r=this.findContainerIndex(s,t)>=0;if(r||B(s))r&&(this.state.mostRecentlyFocusedNode=s);else{t.stopImmediatePropagation();let i,c=!0;if(this.state.mostRecentlyFocusedNode)if(g(this.state.mostRecentlyFocusedNode)>0){const u=this.findContainerIndex(this.state.mostRecentlyFocusedNode),{tabbableNodes:o}=this.state.containerGroups[u];if(o.length>0){const d=o.findIndex(f=>f===this.state.mostRecentlyFocusedNode);d>=0&&(this.config.isKeyForward(this.state.recentNavEvent)?d+1<o.length&&(i=o[d+1],c=!1):d-1>=0&&(i=o[d-1],c=!1))}}else this.state.containerGroups.some(u=>u.tabbableNodes.some(o=>g(o)>0))||(c=!1);else c=!1;c&&(i=this.findNextNavNode({target:this.state.mostRecentlyFocusedNode,isBackward:this.config.isKeyBackward(this.state.recentNavEvent)})),i?this.tryFocus(i):this.tryFocus(this.state.mostRecentlyFocusedNode||this.getInitialFocusNode())}this.state.recentNavEvent=void 0}),l(this,"handlePointerDown",t=>{const s=y(t);if(!(this.findContainerIndex(s,t)>=0)){if(N(this.config.clickOutsideDeactivates,t)){this.deactivate({returnFocus:this.config.returnFocusOnDeactivate});return}N(this.config.allowOutsideClick,t)||t.preventDefault()}}),l(this,"handleClick",t=>{const s=y(t);this.findContainerIndex(s,t)>=0||N(this.config.clickOutsideDeactivates,t)||N(this.config.allowOutsideClick,t)||(t.preventDefault(),t.stopImmediatePropagation())}),l(this,"handleTabKey",t=>{if(this.config.isKeyForward(t)||this.config.isKeyBackward(t)){this.state.recentNavEvent=t;const s=this.config.isKeyBackward(t),r=this.findNextNavNode({event:t,isBackward:s});if(!r)return;F(t)&&t.preventDefault(),this.tryFocus(r)}}),l(this,"handleEscapeKey",t=>{W(t)&&N(this.config.escapeDeactivates,t)!==!1&&(t.preventDefault(),this.deactivate())}),l(this,"_mutationObserver"),l(this,"setupMutationObserver",()=>{const t=this.doc.defaultView||window;this._mutationObserver=new t.MutationObserver(s=>{s.some(i=>Array.from(i.removedNodes).some(u=>u===this.state.mostRecentlyFocusedNode))&&this.tryFocus(this.getInitialFocusNode())})}),l(this,"updateObservedNodes",()=>{var t;(t=this._mutationObserver)==null||t.disconnect(),this.state.active&&!this.state.paused&&this.state.containers.map(s=>{var r;(r=this._mutationObserver)==null||r.observe(s,{subtree:!0,childList:!0})})}),l(this,"getInitialFocusNode",()=>{let t=this.getNodeForOption("initialFocus",{hasFallback:!0});if(t===!1)return!1;if(t===void 0||t&&!T(t))if(this.findContainerIndex(this.doc.activeElement)>=0)t=this.doc.activeElement;else{const s=this.state.tabbableGroups[0];t=s&&s.firstTabbableNode||this.getNodeForOption("fallbackFocus")}else t===null&&(t=this.getNodeForOption("fallbackFocus"));if(!t)throw new Error("Your focus-trap needs to have at least one focusable element");return t.isConnected||(t=this.getNodeForOption("fallbackFocus")),t}),l(this,"tryFocus",t=>{if(t!==!1&&t!==P(this.doc)){if(!t||!t.focus){this.tryFocus(this.getInitialFocusNode());return}t.focus({preventScroll:!!this.config.preventScroll}),this.state.mostRecentlyFocusedNode=t,X(t)&&t.select()}}),l(this,"deactivate",t=>{if(!this.state.active)return this;const s={onDeactivate:this.config.onDeactivate,onPostDeactivate:this.config.onPostDeactivate,checkCanReturnFocus:this.config.checkCanReturnFocus,...t};clearTimeout(this.state.delayInitialFocusTimer),this.state.delayInitialFocusTimer=void 0,this.removeListeners(),this.state.active=!1,this.state.paused=!1,this.updateObservedNodes(),I.deactivateTrap(this.trapStack,this);const r=this.getOption(s,"onDeactivate"),i=this.getOption(s,"onPostDeactivate"),c=this.getOption(s,"checkCanReturnFocus"),u=this.getOption(s,"returnFocus","returnFocusOnDeactivate");r==null||r();const o=()=>{C(()=>{if(u){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);this.tryFocus(d)}i==null||i()})};if(u&&c){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);return c(d).then(o,o),this}return o(),this}),l(this,"pause",t=>{if(this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onPause"),r=this.getOption(t,"onPostPause");return this.state.paused=!0,s==null||s(),this.removeListeners(),this.updateObservedNodes(),r==null||r(),this}),l(this,"unpause",t=>{if(!this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onUnpause"),r=this.getOption(t,"onPostUnpause");return this.state.paused=!1,s==null||s(),this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),r==null||r(),this}),l(this,"updateContainerElements",t=>(this.state.containers=Array.isArray(t)?t.filter(Boolean):[t].filter(Boolean),this.state.active&&this.updateTabbableNodes(),this.updateObservedNodes(),this)),l(this,"getReturnFocusNode",t=>{const s=this.getNodeForOption("setReturnFocus",{params:[t]});return s||(s===!1?!1:t)}),l(this,"getOption",(t,s,r)=>t&&t[s]!==void 0?t[s]:this.config[r||s]),l(this,"getNodeForOption",(t,{hasFallback:s=!1,params:r=[]}={})=>{let i=this.config[t];if(typeof i=="function"&&(i=i(...r)),i===!0&&(i=void 0),!i){if(i===void 0||i===!1)return i;throw new Error(`\`${t}\` was specified but was not a node, or did not return a node`)}let c=i;if(typeof i=="string"){try{c=this.doc.querySelector(i)}catch(u){throw new Error(`\`${t}\` appears to be an invalid selector; error="${u.message}"`)}if(!c&&!s)throw new Error(`\`${t}\` as selector refers to no known node`)}return c}),l(this,"findNextNavNode",t=>{const{event:s,isBackward:r=!1}=t,i=t.target||y(s);this.updateTabbableNodes();let c=null;if(this.state.tabbableGroups.length>0){const u=this.findContainerIndex(i,s),o=u>=0?this.state.containerGroups[u]:void 0;if(u<0)r?c=this.state.tabbableGroups[this.state.tabbableGroups.length-1].lastTabbableNode:c=this.state.tabbableGroups[0].firstTabbableNode;else if(r){let d=this.state.tabbableGroups.findIndex(({firstTabbableNode:f})=>i===f);if(d<0&&((o==null?void 0:o.container)===i||T(i)&&!p(i)&&!(o!=null&&o.nextTabbableNode(i,!1)))&&(d=u),d>=0){const f=d===0?this.state.tabbableGroups.length-1:d-1,h=this.state.tabbableGroups[f];c=g(i)>=0?h.lastTabbableNode:h.lastDomTabbableNode}else F(s)||(c=o==null?void 0:o.nextTabbableNode(i,!1))}else{let d=this.state.tabbableGroups.findIndex(({lastTabbableNode:f})=>i===f);if(d<0&&((o==null?void 0:o.container)===i||T(i)&&!p(i)&&!(o!=null&&o.nextTabbableNode(i)))&&(d=u),d>=0){const f=d===this.state.tabbableGroups.length-1?0:d+1,h=this.state.tabbableGroups[f];c=g(i)>=0?h.firstTabbableNode:h.firstDomTabbableNode}else F(s)||(c=o==null?void 0:o.nextTabbableNode(i))}}else c=this.getNodeForOption("fallbackFocus");return c}),this.trapStack=a.trapStack||$;const n={returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0,isKeyForward(t){return F(t)&&!t.shiftKey},isKeyBackward(t){return F(t)&&t.shiftKey},...a};this.doc=n.document||D(Array.isArray(e)?e[0]:e),this.config=n,this.updateContainerElements(e),this.setupMutationObserver()}get active(){return this.state.active}get paused(){return this.state.paused}findContainerIndex(e,a){const n=typeof(a==null?void 0:a.composedPath)=="function"?a.composedPath():void 0;return this.state.containerGroups.findIndex(({container:t,tabbableNodes:s})=>t.contains(e)||(n==null?void 0:n.includes(t))||s.find(r=>r===e))}updateTabbableNodes(){if(this.state.containerGroups=this.state.containers.map(e=>{const a=G(e),n=A(e),t=a.length>0?a[0]:void 0,s=a.length>0?a[a.length-1]:void 0,r=n.find(o=>p(o)),i=n.slice().reverse().find(o=>p(o)),c=!!a.find(o=>g(o)>0);function u(o,d=!0){const f=a.indexOf(o);return f<0?d?n.slice(n.indexOf(o)+1).find(h=>p(h)):n.slice(0,n.indexOf(o)).reverse().find(h=>p(h)):a[f+(d?1:-1)]}return{container:e,tabbableNodes:a,focusableNodes:n,posTabIndexesFound:c,firstTabbableNode:t,lastTabbableNode:s,firstDomTabbableNode:r,lastDomTabbableNode:i,nextTabbableNode:u}}),this.state.tabbableGroups=this.state.containerGroups.filter(e=>e.tabbableNodes.length>0),this.state.tabbableGroups.length<=0&&!this.getNodeForOption("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");if(this.state.containerGroups.find(e=>e.posTabIndexesFound)&&this.state.containerGroups.length>1)throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")}addListeners(){if(this.state.active)return I.activateTrap(this.trapStack,this),this.state.delayInitialFocusTimer=this.config.delayInitialFocus?C(()=>{this.tryFocus(this.getInitialFocusNode())}):this.tryFocus(this.getInitialFocusNode()),this.listenerCleanups.push(v(this.doc,"focusin",this.handleFocus,!0),v(this.doc,"mousedown",this.handlePointerDown,{capture:!0,passive:!1}),v(this.doc,"touchstart",this.handlePointerDown,{capture:!0,passive:!1}),v(this.doc,"click",this.handleClick,{capture:!0,passive:!1}),v(this.doc,"keydown",this.handleTabKey,{capture:!0,passive:!1}),v(this.doc,"keydown",this.handleEscapeKey)),this}removeListeners(){if(this.state.active)return this.listenerCleanups.forEach(e=>e()),this.listenerCleanups=[],this}activate(e){if(this.state.active)return this;const a=this.getOption(e,"onActivate"),n=this.getOption(e,"onPostActivate"),t=this.getOption(e,"checkCanFocusTrap");t||this.updateTabbableNodes(),this.state.active=!0,this.state.paused=!1,this.state.nodeFocusedBeforeActivation=this.doc.activeElement||null,a==null||a();const s=()=>{t&&this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),n==null||n()};return t?(t(this.state.containers.concat()).then(s,s),this):(s(),this)}},F=e=>e.key==="Tab",N=(e,...a)=>typeof e=="function"?e(...a):e,W=e=>!e.isComposing&&e.key==="Escape",C=e=>setTimeout(e,0),X=e=>e.localName==="input"&&"select"in e&&typeof e.select=="function";function z(e,a={}){let n;const t=R(()=>{const s=typeof e=="function"?e():e;if(s){n=new M(s,{escapeDeactivates:!1,allowOutsideClick:!0,preventScroll:!0,returnFocusOnDeactivate:!0,delayInitialFocus:!1,fallbackFocus:s,...a,document:D(s)});try{n.activate()}catch{}}});return function(){n==null||n.deactivate(),t()}}var w="data-scroll-lock";function Y(e){const a=e.getBoundingClientRect().left;return Math.round(a)+e.scrollLeft?"paddingLeft":"paddingRight"}function H(e){const a=e??document,n=a.defaultView??window,{documentElement:t,body:s}=a;if(s.hasAttribute(w))return;const i=n.innerWidth-t.clientWidth;s.setAttribute(w,"");const c=()=>K(t,"--scrollbar-width",`${i}px`),u=Y(t),o=()=>O(s,{overflow:"hidden",[u]:`${i}px`}),d=()=>{const{scrollX:h,scrollY:x,visualViewport:b}=n,k=(b==null?void 0:b.offsetLeft)??0,E=(b==null?void 0:b.offsetTop)??0,m=O(s,{position:"fixed",overflow:"hidden",top:`${-(x-Math.floor(E))}px`,left:`${-(h-Math.floor(k))}px`,right:"0",[u]:`${i}px`});return()=>{m==null||m(),n.scrollTo({left:h,top:x,behavior:"instant"})}},f=[c(),L()?d():o()];return()=>{f.forEach(h=>h==null?void 0:h()),s.removeAttribute(w)}}export{H as p,z as t};
