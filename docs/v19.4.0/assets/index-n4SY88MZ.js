import{r as L,b as P,E as M,F as S,G as g,H as y,l as N,I as C,d as I,J as _,o as A,K as W,y as R,L as $}from"./use-locale-context-Da8UBLVe.js";var F=new WeakMap,O=new WeakMap,k={},D=0,K=e=>e&&(e.host||K(e.parentNode)),H=(e,i)=>i.map(o=>{if(e.contains(o))return o;const t=K(o);return t&&e.contains(t)?t:(console.error("[zag-js > ariaHidden] target",o,"in not contained inside",e,". Doing nothing"),null)}).filter(o=>!!o),V=new Set(["script","output","status","next-route-announcer"]),X=e=>V.has(e.localName)||e.role==="status"||e.hasAttribute("aria-live")?!0:e.matches("[data-live-announcer]"),Y=(e,i)=>{const{parentNode:o,markerName:t,controlAttribute:s}=i,r=H(o,Array.isArray(e)?e:[e]);k[t]||(k[t]=new WeakMap);const a=k[t],u=[],l=new Set,n=new Set(r),d=c=>{!c||l.has(c)||(l.add(c),d(c.parentNode))};r.forEach(d);const b=c=>{!c||n.has(c)||Array.prototype.forEach.call(c.children,f=>{if(l.has(f))b(f);else try{if(X(f))return;const T=f.getAttribute(s)==="true",x=(F.get(f)||0)+1,v=(a.get(f)||0)+1;F.set(f,x),a.set(f,v),u.push(f),x===1&&T&&O.set(f,!0),v===1&&f.setAttribute(t,""),T||f.setAttribute(s,"true")}catch(p){console.error("[zag-js > ariaHidden] cannot operate on ",f,p)}})};return b(o),l.clear(),D++,()=>{u.forEach(c=>{const f=F.get(c)-1,p=a.get(c)-1;F.set(c,f),a.set(c,p),f||(O.has(c)||c.removeAttribute(s),O.delete(c)),p||c.removeAttribute(t)}),D--,D||(F=new WeakMap,F=new WeakMap,O=new WeakMap,k={})}},q=e=>(Array.isArray(e)?e[0]:e).ownerDocument.body,z=(e,i=q(e),o="data-aria-hidden")=>{if(i)return Y(e,{parentNode:i,markerName:o,controlAttribute:"aria-hidden"})},j=e=>{const i=requestAnimationFrame(()=>e());return()=>cancelAnimationFrame(i)};function at(e,i={}){const{defer:o=!0}=i,t=o?j:r=>r(),s=[];return s.push(t(()=>{const a=(typeof e=="function"?e():e).filter(Boolean);a.length!==0&&s.push(z(a))})),()=>{s.forEach(r=>r==null?void 0:r())}}var J=Object.defineProperty,Q=(e,i,o)=>i in e?J(e,i,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[i]=o,h=(e,i,o)=>Q(e,typeof i!="symbol"?i+"":i,o),G={activateTrap(e,i){if(e.length>0){const t=e[e.length-1];t!==i&&t.pause()}const o=e.indexOf(i);o===-1||e.splice(o,1),e.push(i)},deactivateTrap(e,i){const o=e.indexOf(i);o!==-1&&e.splice(o,1),e.length>0&&e[e.length-1].unpause()}},U=[],Z=class{constructor(e,i){h(this,"trapStack"),h(this,"config"),h(this,"doc"),h(this,"state",{containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0,recentNavEvent:void 0}),h(this,"listenerCleanups",[]),h(this,"handleFocus",t=>{const s=I(t),r=this.findContainerIndex(s,t)>=0;if(r||_(s))r&&(this.state.mostRecentlyFocusedNode=s);else{t.stopImmediatePropagation();let a,u=!0;if(this.state.mostRecentlyFocusedNode)if(y(this.state.mostRecentlyFocusedNode)>0){const l=this.findContainerIndex(this.state.mostRecentlyFocusedNode),{tabbableNodes:n}=this.state.containerGroups[l];if(n.length>0){const d=n.findIndex(b=>b===this.state.mostRecentlyFocusedNode);d>=0&&(this.config.isKeyForward(this.state.recentNavEvent)?d+1<n.length&&(a=n[d+1],u=!1):d-1>=0&&(a=n[d-1],u=!1))}}else this.state.containerGroups.some(l=>l.tabbableNodes.some(n=>y(n)>0))||(u=!1);else u=!1;u&&(a=this.findNextNavNode({target:this.state.mostRecentlyFocusedNode,isBackward:this.config.isKeyBackward(this.state.recentNavEvent)})),a?this.tryFocus(a):this.tryFocus(this.state.mostRecentlyFocusedNode||this.getInitialFocusNode())}this.state.recentNavEvent=void 0}),h(this,"handlePointerDown",t=>{const s=I(t);if(!(this.findContainerIndex(s,t)>=0)){if(w(this.config.clickOutsideDeactivates,t)){this.deactivate({returnFocus:this.config.returnFocusOnDeactivate});return}w(this.config.allowOutsideClick,t)||t.preventDefault()}}),h(this,"handleClick",t=>{const s=I(t);this.findContainerIndex(s,t)>=0||w(this.config.clickOutsideDeactivates,t)||w(this.config.allowOutsideClick,t)||(t.preventDefault(),t.stopImmediatePropagation())}),h(this,"handleTabKey",t=>{if(this.config.isKeyForward(t)||this.config.isKeyBackward(t)){this.state.recentNavEvent=t;const s=this.config.isKeyBackward(t),r=this.findNextNavNode({event:t,isBackward:s});if(!r)return;m(t)&&t.preventDefault(),this.tryFocus(r)}}),h(this,"handleEscapeKey",t=>{tt(t)&&w(this.config.escapeDeactivates,t)!==!1&&(t.preventDefault(),this.deactivate())}),h(this,"_mutationObserver"),h(this,"setupMutationObserver",()=>{const t=this.doc.defaultView||window;this._mutationObserver=new t.MutationObserver(s=>{s.some(a=>Array.from(a.removedNodes).some(l=>l===this.state.mostRecentlyFocusedNode))&&this.tryFocus(this.getInitialFocusNode())})}),h(this,"updateObservedNodes",()=>{var t;(t=this._mutationObserver)==null||t.disconnect(),this.state.active&&!this.state.paused&&this.state.containers.map(s=>{var r;(r=this._mutationObserver)==null||r.observe(s,{subtree:!0,childList:!0})})}),h(this,"getInitialFocusNode",()=>{let t=this.getNodeForOption("initialFocus",{hasFallback:!0});if(t===!1)return!1;if(t===void 0||t&&!A(t)){const s=C(this.doc);if(s&&this.findContainerIndex(s)>=0)t=s;else{const r=this.state.tabbableGroups[0];t=r&&r.firstTabbableNode||this.getNodeForOption("fallbackFocus")}}else t===null&&(t=this.getNodeForOption("fallbackFocus"));if(!t)throw new Error("Your focus-trap needs to have at least one focusable element");return t.isConnected||(t=this.getNodeForOption("fallbackFocus")),t}),h(this,"tryFocus",t=>{if(t!==!1&&t!==C(this.doc)){if(!t||!t.focus){this.tryFocus(this.getInitialFocusNode());return}t.focus({preventScroll:!!this.config.preventScroll}),this.state.mostRecentlyFocusedNode=t,et(t)&&t.select()}}),h(this,"deactivate",t=>{if(!this.state.active)return this;const s={onDeactivate:this.config.onDeactivate,onPostDeactivate:this.config.onPostDeactivate,checkCanReturnFocus:this.config.checkCanReturnFocus,...t};clearTimeout(this.state.delayInitialFocusTimer),this.state.delayInitialFocusTimer=void 0,this.removeListeners(),this.state.active=!1,this.state.paused=!1,this.updateObservedNodes(),G.deactivateTrap(this.trapStack,this);const r=this.getOption(s,"onDeactivate"),a=this.getOption(s,"onPostDeactivate"),u=this.getOption(s,"checkCanReturnFocus"),l=this.getOption(s,"returnFocus","returnFocusOnDeactivate");r==null||r();const n=()=>{B(()=>{if(l){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);this.tryFocus(d)}a==null||a()})};if(l&&u){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);return u(d).then(n,n),this}return n(),this}),h(this,"pause",t=>{if(this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onPause"),r=this.getOption(t,"onPostPause");return this.state.paused=!0,s==null||s(),this.removeListeners(),this.updateObservedNodes(),r==null||r(),this}),h(this,"unpause",t=>{if(!this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onUnpause"),r=this.getOption(t,"onPostUnpause");return this.state.paused=!1,s==null||s(),this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),r==null||r(),this}),h(this,"updateContainerElements",t=>(this.state.containers=Array.isArray(t)?t.filter(Boolean):[t].filter(Boolean),this.state.active&&this.updateTabbableNodes(),this.updateObservedNodes(),this)),h(this,"getReturnFocusNode",t=>{const s=this.getNodeForOption("setReturnFocus",{params:[t]});return s||(s===!1?!1:t)}),h(this,"getOption",(t,s,r)=>t&&t[s]!==void 0?t[s]:this.config[r||s]),h(this,"getNodeForOption",(t,{hasFallback:s=!1,params:r=[]}={})=>{let a=this.config[t];if(typeof a=="function"&&(a=a(...r)),a===!0&&(a=void 0),!a){if(a===void 0||a===!1)return a;throw new Error(`\`${t}\` was specified but was not a node, or did not return a node`)}let u=a;if(typeof a=="string"){try{u=this.doc.querySelector(a)}catch(l){throw new Error(`\`${t}\` appears to be an invalid selector; error="${l.message}"`)}if(!u&&!s)throw new Error(`\`${t}\` as selector refers to no known node`)}return u}),h(this,"findNextNavNode",t=>{const{event:s,isBackward:r=!1}=t,a=t.target||I(s);this.updateTabbableNodes();let u=null;if(this.state.tabbableGroups.length>0){const l=this.findContainerIndex(a,s),n=l>=0?this.state.containerGroups[l]:void 0;if(l<0)r?u=this.state.tabbableGroups[this.state.tabbableGroups.length-1].lastTabbableNode:u=this.state.tabbableGroups[0].firstTabbableNode;else if(r){let d=this.state.tabbableGroups.findIndex(({firstTabbableNode:b})=>a===b);if(d<0&&((n==null?void 0:n.container)===a||A(a)&&!g(a)&&!(n!=null&&n.nextTabbableNode(a,!1)))&&(d=l),d>=0){const b=d===0?this.state.tabbableGroups.length-1:d-1,c=this.state.tabbableGroups[b];u=y(a)>=0?c.lastTabbableNode:c.lastDomTabbableNode}else m(s)||(u=n==null?void 0:n.nextTabbableNode(a,!1))}else{let d=this.state.tabbableGroups.findIndex(({lastTabbableNode:b})=>a===b);if(d<0&&((n==null?void 0:n.container)===a||A(a)&&!g(a)&&!(n!=null&&n.nextTabbableNode(a)))&&(d=l),d>=0){const b=d===this.state.tabbableGroups.length-1?0:d+1,c=this.state.tabbableGroups[b];u=y(a)>=0?c.firstTabbableNode:c.firstDomTabbableNode}else m(s)||(u=n==null?void 0:n.nextTabbableNode(a))}}else u=this.getNodeForOption("fallbackFocus");return u}),this.trapStack=i.trapStack||U;const o={returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0,isKeyForward(t){return m(t)&&!t.shiftKey},isKeyBackward(t){return m(t)&&t.shiftKey},...i};this.doc=o.document||P(Array.isArray(e)?e[0]:e),this.config=o,this.updateContainerElements(e),this.setupMutationObserver()}get active(){return this.state.active}get paused(){return this.state.paused}findContainerIndex(e,i){const o=typeof(i==null?void 0:i.composedPath)=="function"?i.composedPath():void 0;return this.state.containerGroups.findIndex(({container:t,tabbableNodes:s})=>t.contains(e)||(o==null?void 0:o.includes(t))||s.find(r=>r===e))}updateTabbableNodes(){if(this.state.containerGroups=this.state.containers.map(e=>{const i=M(e),o=S(e),t=i.length>0?i[0]:void 0,s=i.length>0?i[i.length-1]:void 0,r=o.find(n=>g(n)),a=o.slice().reverse().find(n=>g(n)),u=!!i.find(n=>y(n)>0);function l(n,d=!0){const b=i.indexOf(n);return b<0?d?o.slice(o.indexOf(n)+1).find(c=>g(c)):o.slice(0,o.indexOf(n)).reverse().find(c=>g(c)):i[b+(d?1:-1)]}return{container:e,tabbableNodes:i,focusableNodes:o,posTabIndexesFound:u,firstTabbableNode:t,lastTabbableNode:s,firstDomTabbableNode:r,lastDomTabbableNode:a,nextTabbableNode:l}}),this.state.tabbableGroups=this.state.containerGroups.filter(e=>e.tabbableNodes.length>0),this.state.tabbableGroups.length<=0&&!this.getNodeForOption("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");if(this.state.containerGroups.find(e=>e.posTabIndexesFound)&&this.state.containerGroups.length>1)throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")}addListeners(){if(this.state.active)return G.activateTrap(this.trapStack,this),this.state.delayInitialFocusTimer=this.config.delayInitialFocus?B(()=>{this.tryFocus(this.getInitialFocusNode())}):this.tryFocus(this.getInitialFocusNode()),this.listenerCleanups.push(N(this.doc,"focusin",this.handleFocus,!0),N(this.doc,"mousedown",this.handlePointerDown,{capture:!0,passive:!1}),N(this.doc,"touchstart",this.handlePointerDown,{capture:!0,passive:!1}),N(this.doc,"click",this.handleClick,{capture:!0,passive:!1}),N(this.doc,"keydown",this.handleTabKey,{capture:!0,passive:!1}),N(this.doc,"keydown",this.handleEscapeKey)),this}removeListeners(){if(this.state.active)return this.listenerCleanups.forEach(e=>e()),this.listenerCleanups=[],this}activate(e){if(this.state.active)return this;const i=this.getOption(e,"onActivate"),o=this.getOption(e,"onPostActivate"),t=this.getOption(e,"checkCanFocusTrap");t||this.updateTabbableNodes(),this.state.active=!0,this.state.paused=!1,this.state.nodeFocusedBeforeActivation=C(this.doc),i==null||i();const s=()=>{t&&this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),o==null||o()};return t?(t(this.state.containers.concat()).then(s,s),this):(s(),this)}},m=e=>e.key==="Tab",w=(e,...i)=>typeof e=="function"?e(...i):e,tt=e=>!e.isComposing&&e.key==="Escape",B=e=>setTimeout(e,0),et=e=>e.localName==="input"&&"select"in e&&typeof e.select=="function";function ot(e,i={}){let o;const t=L(()=>{const s=typeof e=="function"?e():e;if(s){o=new Z(s,{escapeDeactivates:!1,allowOutsideClick:!0,preventScroll:!0,returnFocusOnDeactivate:!0,delayInitialFocus:!1,fallbackFocus:s,...i,document:P(s)});try{o.activate()}catch{}}});return function(){o==null||o.deactivate(),t()}}var E="data-scroll-lock";function st(e){const i=e.getBoundingClientRect().left;return Math.round(i)+e.scrollLeft?"paddingLeft":"paddingRight"}function rt(e){const i=e??document,o=i.defaultView??window,{documentElement:t,body:s}=i;if(s.hasAttribute(E))return;const a=o.innerWidth-t.clientWidth;s.setAttribute(E,"");const u=()=>W(t,"--scrollbar-width",`${a}px`),l=st(t),n=()=>R(s,{overflow:"hidden",[l]:`${a}px`}),d=()=>{const{scrollX:c,scrollY:f,visualViewport:p}=o,T=(p==null?void 0:p.offsetLeft)??0,x=(p==null?void 0:p.offsetTop)??0,v=R(s,{position:"fixed",overflow:"hidden",top:`${-(f-Math.floor(x))}px`,left:`${-(c-Math.floor(T))}px`,right:"0",[l]:`${a}px`});return()=>{v==null||v(),o.scrollTo({left:c,top:f,behavior:"instant"})}},b=[u(),$()?d():n()];return()=>{b.forEach(c=>c==null?void 0:c()),s.removeAttribute(E)}}export{at as a,rt as p,ot as t};
